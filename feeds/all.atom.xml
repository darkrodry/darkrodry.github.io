<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>El blog de DarkRodry</title><link href="https://darkrodry.github.io/" rel="alternate"></link><link href="https://darkrodry.github.io/feeds/all.atom.xml" rel="self"></link><id>https://darkrodry.github.io/</id><updated>2023-04-02T00:00:00+02:00</updated><subtitle>Miscelaneous Developer</subtitle><entry><title>Sufijos en tags de Docker</title><link href="https://darkrodry.github.io/sufijos-docker.html" rel="alternate"></link><published>2022-07-29T00:00:00+02:00</published><updated>2022-07-29T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2022-07-29:/sufijos-docker.html</id><summary type="html">&lt;p&gt;El otro día en el trabajo estuve mirando con un compañero para actualizar la imagen de docker que estábamos ejecutando en el pipeline y empezamos a ver imágenes con coletillas de &lt;em&gt;buster&lt;/em&gt;, &lt;em&gt;alpine&lt;/em&gt; o &lt;em&gt;bullseye&lt;/em&gt;, momento en el que nos empezamos a mirar con cara de poker sin saber muy bien cuál elegir. En este artículo, a modo de chuleta, explico los nombres más comunes que puedes encontrar en los contenedores de Dockerhub.&lt;/p&gt;</summary><content type="html">&lt;p&gt;El otro día en el trabajo estuve mirando con un compañero para actualizar la imagen de docker que estábamos ejecutando en el pipeline y empezamos a ver imágenes con coletillas de &lt;em&gt;buster&lt;/em&gt;, &lt;em&gt;alpine&lt;/em&gt; o &lt;em&gt;bullseye&lt;/em&gt;, momento en el que nos empezamos a mirar con cara de poker sin saber muy bien cuál elegir. En este artículo, a modo de chuleta, explico los nombres más comunes que puedes encontrar en los contenedores de Dockerhub.&lt;/p&gt;
&lt;p&gt;A modo de ejemplo he elegido la imagen de &lt;a href="https://hub.docker.com/_/node/"&gt;node 16&lt;/a&gt; (actualmente está la 18) para detallar todos estos sufijos.&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto; width: 1000%" src="images/docker-node-tags.png" alt="docker node tags example"&gt;&lt;/p&gt;
&lt;h3&gt;Imagen por defecto&lt;/h3&gt;
&lt;p&gt;La imagen oficial, sin nada extra, se puede bajar como &lt;code&gt;node:16&lt;/code&gt; (o &lt;code&gt;node:16.16.0&lt;/code&gt; para bajar una versión concreta).&lt;/p&gt;
&lt;h3&gt;alpine&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://alpinelinux.org/"&gt;Alpine&lt;/a&gt; es una distribución de Linux creada específicamente para usarse en contenedores. Es una distribucióncreada con la intención de ser segura y ligera, lo cual puede ser bueno si el tamaño es un requisito pero son imágenes que carecen de muchas utilidades de Linux como &lt;code&gt;bash&lt;/code&gt; o &lt;code&gt;git&lt;/code&gt;. En el caso de node, estas imágenes están etiquetadas como &lt;code&gt;node:16.16.0-alpine&lt;/code&gt;, existiendo variantes para versiones de esta distribución (&lt;code&gt;alpine3.15&lt;/code&gt; y &lt;code&gt;alpine3.16&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Debian releases&lt;/h3&gt;
&lt;p&gt;Otra distribución de Linux que se usa para contenedores es &lt;a href="https://www.debian.org/"&gt;Debian&lt;/a&gt;, con sus &lt;a href="https://www.debian.org/releases/"&gt;diferentes releases&lt;/a&gt;. Estas releases (&lt;em&gt;bullseye&lt;/em&gt;, &lt;em&gt;buster&lt;/em&gt; o &lt;em&gt;strech&lt;/em&gt; son las tres mas recientes ahora mismo) indican la versión de Debian en la que se basa el contenedor. Para node las puedes bajar como &lt;code&gt;node:16.16.0-bullseye&lt;/code&gt; o &lt;code&gt;node:16.16.0-buster&lt;/code&gt; en función de lo que busques.&lt;/p&gt;
&lt;h3&gt;slim&lt;/h3&gt;
&lt;p&gt;Estas imágenes, normalmente a partir de releases de Debian, son imágenes que contienen los paquetes básicos de la distribución de Linux para que funcione el contenedor. Al igual que con alpine, estas imagenes son solo recomendables si el tamaño es un requisito. La etiqueta para este caso es &lt;code&gt;node:16.16.0-slim&lt;/code&gt; para la slim por defecto o &lt;code&gt;node:16.16.0-bullseye-slim&lt;/code&gt; si quieres especificar una versión concreta.&lt;/p&gt;
&lt;h3&gt;windowsservercore&lt;/h3&gt;
&lt;p&gt;En el caso de necesitar imágenes con Windows, algunos contenedores disponen del sufijo &lt;code&gt;-windowsservercore&lt;/code&gt; que basa la imagen en &lt;a href="https://hub.docker.com/_/microsoft-windows-servercore"&gt;Windows Server Core&lt;/a&gt;. En el caso de node no hay nada basado en Windows, ya que no tiene la necesidad, pero podemos encontrar ejemplos de esto en &lt;a href="https://hub.docker.com/_/golang"&gt;golang&lt;/a&gt; con el tag &lt;code&gt;golang:1.18.4-windowsservercore&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;¿Cuál elegir?&lt;/h3&gt;
&lt;p&gt;Si miras el apartado final de la página de node en Dockerhub (Image Variants), y en general en todas las páginas de imágenes importante, suelen recomendar que imagen usar. Las recomendaciones suelen ser usar la imagen por defecto si no tienes problemas de tamaño y la versión slim en caso de que el tamaño sea un problema. Piensa que una de las ventajas de Docker es que una vez descargado un contenedor, las siguientes descargar son "gratis" ya que la imagen estará cacheada.&lt;/p&gt;</content><category term="DevOps"></category><category term="docker"></category><category term="tech"></category></entry><entry><title>Tácticas para monitorización</title><link href="https://darkrodry.github.io/tacticas-monitorizacion.html" rel="alternate"></link><published>2022-07-10T00:00:00+02:00</published><updated>2022-07-10T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2022-07-10:/tacticas-monitorizacion.html</id><summary type="html">&lt;p&gt;En esta segunda parte del resumen de &lt;em&gt;Practical Monitoring&lt;/em&gt; nos centraremos más en que puntos de todo el sistema monitorizar, desde los diferentes puntos de vista de todas sus componentes: negocio, aplicaciones, infraestructura, seguridad...&lt;/p&gt;</summary><content type="html">&lt;p&gt;En el &lt;a href="principios-basicos-monitorizacion.html"&gt;anterior artículo&lt;/a&gt; hice un resumen sobre cuales son los principios básicos para monitorizar tus aplicaciones: la importancia que tiene y varios patrones y antipatrones a tener en cuenta. En esta segunda parte nos centraremos más en que puntos de todo el sistema monitorizar, desde los diferentes puntos de vista de todas sus componentes: negocio, aplicaciones, infraestructura, seguridad...&lt;/p&gt;
&lt;h3&gt;Monitorizar el negocio&lt;/h3&gt;
&lt;p&gt;Uno de los puntos más importantes sobre el que tener métricas es el negocio. Es la forma más rápida de ver si el sistema está funcionando correctamente o el impacto que pueden tener nuevos desarrollos sobre todo el sistema. Para poder saber que testear correctamente, es importante definir unos buenos KPIs (key performance indicator) y relacionar estos KPI con elementos de nuestro sistema.&lt;/p&gt;
&lt;p&gt;Hay varios KPI comunes en las empresas: ingresos recurrentes mensuales, los ingresos por empleado, el &lt;a href="https://es.wikipedia.org/wiki/Net_Promoter_Score"&gt;NPS&lt;/a&gt;, el &lt;em&gt;customer lifetime value&lt;/em&gt;, el coste de adquisición de usuario, el margen de beneficios... Trata de buscar cómo impacta la plataforma en estos valores y agrega métricas para detectar comportamientos extraños lo antes posible. Ejemplos pueden ser el número total de usuarios activos o los productos/servicios contratados (por los que se paga dinero).&lt;/p&gt;
&lt;h3&gt;Monitorizar el frontend&lt;/h3&gt;
&lt;p&gt;Una de las cosas a las que menos atención se le presta es a las métricas de los diferentes clientes en nuestro sistema. A la hora de obtener métricas en front hay dos tipos de aproximaciones: monitorización de usuarios reales (RUM) y de usuarios sintéticos (creando falsas peticiones bajo diferentes condiciones).&lt;/p&gt;
&lt;p&gt;Una herramienta muy común para monitorizar fronts es Google Analytics, una herramienta tipo RUM que analiza cómo interacciona el usuario con el cliente.&lt;/p&gt;
&lt;p&gt;A la hora de monitorizar el front, es importante controlar el tiempo de carga de las diferentes páginas usando el &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming"&gt;API &lt;em&gt;PerformanceNavigationTiming&lt;/em&gt;&lt;/a&gt; (utiliza los eventos &lt;code&gt;domComplete - navigationStart&lt;/code&gt; y &lt;code&gt;domInteractive - navigationStart&lt;/code&gt;). También es bueno almacenar logs (y no volcarlos por &lt;code&gt;console.log()&lt;/code&gt;) y enviar los errores de JavScript.&lt;/p&gt;
&lt;p&gt;Cualquier métrica relacionada con los tiempos de carga puede ser integrada en tu flujo de CI para asegurar que se mantienen unos tiempos adecuados, y también hay soluciones para configurar&lt;/p&gt;
&lt;h3&gt;Monitorizar el backend&lt;/h3&gt;
&lt;p&gt;Para monitorizar tu aplicación backend es recomendable controlar los servicios clave. Para ello se puede controlar tanto llamadas exitosas/fallidas, duración de cada llamada, etc. Cualquier dato que sea relevante para tu negocio. Para controlar estas métricas existen herramientas como &lt;a href="https://github.com/statsd/statsd"&gt;StatsD&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Estas métricas generadas son muy útiles para controlar las releases, tanto para analizar el uso de nuevas funcionalidad desplegadas como para detectar posibles errores introducidos.&lt;/p&gt;
&lt;p&gt;También es importante generar logs en tu aplicación. Ten cuidado con los logs que generas, ya que es fácil generar logs en exceso (o en defecto). Una buena forma de saber que logear es responder a las preguntas que te harías en caso de que algo falle.&lt;/p&gt;
&lt;p&gt;Otro patrón muy útil en la monitorización es el endpoint de &lt;em&gt;health&lt;/em&gt;, que se utiliza para conocer de un vistazo el estado de la aplicación.&lt;/p&gt;
&lt;p&gt;En el caso de que tu aplicación esté basada en lambdas o microservicios es importante tener trazabilidad de las peticiones entre diferentes piezas, pudiendo analizar el origen y por dónde ha pasado cada petición.&lt;/p&gt;
&lt;h3&gt;Monitorizar el servidor&lt;/h3&gt;
&lt;p&gt;El propio sistema operativo del servidor es capaz de proporcionar métricas útiles: CPU, memoria (RAM, cachés...), estado de red, discos duros, carga del procesador... También es importante controlar otras cosas cómo los certificados SSL, el estado de los servidores web o si los &lt;em&gt;crons&lt;/em&gt; se han ejecutado.&lt;/p&gt;
&lt;p&gt;Dentro de tu servidor puede haber otros componentes que controlar cómo balanceadores de carga, colas de mensajes, la base de datos, cachés, DNS... En caso de estar dentro de una infraestructura corporativa asegúrate también de monitorizar los diferentes elementos dentro de la misma.&lt;/p&gt;
&lt;h3&gt;Monitorizar la red&lt;/h3&gt;
&lt;p&gt;Monitorizar el correcto funcionamiento de la red es una tarea complicada. Existe un protocolo llamado &lt;a href="https://es.wikipedia.org/wiki/Protocolo_simple_de_administraci%C3%B3n_de_red"&gt;SNMP&lt;/a&gt; que se encarga de almacenar y gestionar múltiple métricas, pero su implementación es muy dependiente del fabricante de los equipos. Entre las métricas más comunes está la latencia, el ancho de banda, la capacidad, los errores o el &lt;em&gt;jitter&lt;/em&gt; (fluctuaciones de red)&lt;/p&gt;
&lt;p&gt;Intenta almacenar el historial de configuraciones y de notificar cuando se producen cambios.&lt;/p&gt;
&lt;p&gt;En caso de tener servicios de streaming de voz o video, necesitarás agregar métricas para controlar que ofreces un buen servicio de codificación a tus usuarios.&lt;/p&gt;
&lt;h3&gt;Monitorizar la seguridad&lt;/h3&gt;
&lt;p&gt;Es muy probable que tu sistema tenga que cumplir unas certificaciones de seguridad. Monitorizar estos requisitos (origen de las conexiones, usuarios que las realizan, ejecución de antivirus...) es una forma eficiente de controlar el cumplimiento de los mismos de cara a auditorias.&lt;/p&gt;
&lt;p&gt;Otro punto a controlar son las conexiones SSH efectuadas o las ejecuciones a nivel de superusuario. Puedes usar herramientas como &lt;a href="https://www.man7.org/linux/man-pages/man8/auditd.8.html"&gt;&lt;em&gt;auditd&lt;/em&gt;&lt;/a&gt; para ayudarte con esta tarea. También es importante controlar los &lt;em&gt;syslog&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Una vez dentro de tu sistema, hay que controlar dos frentes usando &lt;em&gt;Host Intrusion Detection Systems&lt;/em&gt; (HIDS) y &lt;em&gt;Network Intrusion Detection Systems&lt;/em&gt; (NIDS). Para el primero es útil usar &lt;a href="http://rkhunter.sourceforge.net/"&gt;&lt;em&gt;rkhunter&lt;/em&gt;&lt;/a&gt; para ayudarte a detectar rootkits. Para ayudarte a analizar el trafico de red dentro de tu infraestructura puedes usar &lt;em&gt;network taps&lt;/em&gt;, que interceptan todo el tráfico y lo envían a otro sistema para su análisis.&lt;/p&gt;</content><category term="Monitoring"></category><category term="libros"></category><category term="tech"></category><category term="monitoring"></category><category term="practical monitoring"></category></entry><entry><title>Principios básicos para monitorización</title><link href="https://darkrodry.github.io/principios-basicos-monitorizacion.html" rel="alternate"></link><published>2022-06-12T00:00:00+02:00</published><updated>2022-07-10T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2022-06-12:/principios-basicos-monitorizacion.html</id><summary type="html">&lt;p&gt;Actualmente ando investigando y mejorando mis conocimientos sobre monitorización. Más allá de una forma de medir el estado de tu sistema, la monitorización permite obtener datos de uso, fallos, estadísticas y otras métricas relacionadas con cómo utilizan los usuarios todo tu trabajo. Todo esto puede ayudarte a la hora de tomar decisiones, ya que con toda esta información puedes saber qué acciones pueden resultar confusas para el usuario, cuáles son los errores que se producen más a menudo y ayudar a simplificar el uso o analizar la aceptación de nuevas funcionalidades. Al final de todo, ¿qué hay mas satisfactorio en nuestro trabajo que ver cómo los usuarios utilizan y están felices con lo que hacemos?&lt;/p&gt;</summary><content type="html">&lt;p&gt;Actualmente ando investigando y mejorando mis conocimientos sobre monitorización. Más allá de una forma de medir el estado de tu sistema, la monitorización permite obtener datos de uso, fallos, estadísticas y otras métricas relacionadas con cómo utilizan los usuarios todo tu trabajo. Todo esto puede ayudarte a la hora de tomar decisiones, ya que con toda esta información puedes saber qué acciones pueden resultar confusas para el usuario, cuáles son los errores que se producen más a menudo y ayudar a simplificar el uso o analizar la aceptación de nuevas funcionalidades. Al final de todo, ¿qué hay mas satisfactorio en nuestro trabajo que ver cómo los usuarios utilizan y están felices con lo que hacemos?&lt;/p&gt;
&lt;p&gt;En este post (y alguno más que iré subiendo) colgaré mis notas sobre el libro &lt;a href="https://www.practicalmonitoring.com/"&gt;Practical Monitoring&lt;/a&gt; de Mike Julian. Es un libro que me está gustando bastante, ya que da una buena introducción al tema agnóstica de cualquier herramienta.&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto; width: 30%" src="images/practical-monitoring.jpg" alt="practical monitoring cover"&gt;&lt;/p&gt;
&lt;h3&gt;Anti patrones&lt;/h3&gt;
&lt;p&gt;En esta sección se agrupan diferentes patrones a evitar a la hora de trabajar en tu sistema de monitorización.&lt;/p&gt;
&lt;h5&gt;Obsesión con las herramientas&lt;/h5&gt;
&lt;p&gt;A la hora de monitorizar, no te obsesiones con las herramientas. Evita crear dependencias entre tu sistema de monitorización y la herramienta (o herramientas) utilizadas. Tampoco debes limitarte a una sola herramienta, ya que no existe una que sea perfecta y te permita controlar todo lo que necesitas. Tampoco de te dejes llevar por modas o por "noseque compañía famosa utiliza tal herramienta". Lo mejor que puedes hacer es buscar la o las herramientas necesarias y, solo en caso de ser necesario, implementar tu propia solución.&lt;/p&gt;
&lt;h5&gt;Considerar la monitorización como un trabajo&lt;/h5&gt;
&lt;p&gt;No hay que considerar la monitorización como responsabilidad de uno o mas miembros del equipo: es responsabilidad de todos. Como desarrollador, tienes que tener el conocimiento y la capacidad para trabajar con la monitorización necesaria para todos tus desarrollos. Al trabajar con una parte concreta de tu aplicación, tienes el contexto de que hay qué y dónde monitorizar, por lo que no hay nadie mejor para implementarlo.&lt;/p&gt;
&lt;h5&gt;Monitorizar por monitorizar&lt;/h5&gt;
&lt;p&gt;Es importante no tener métricas por tenerlas. Suele ser muy común controlar el uso de CPU, el porcentaje de disco, tener alertas que ignoramos... En este caso, deberías replantearte tus métricas planteando que significa que tu sistema funcione y empezar a controlar eso: un endpoint funcionando, una respuesta predeterminada, una web cargando...&lt;/p&gt;
&lt;h5&gt;Monitorizar como soporte&lt;/h5&gt;
&lt;p&gt;Monitorizar no arregla cosas. Está muy bien utilizar la monitorización para notificar errores, pero a parte de arreglar los daños causados por el error es mas importante reparar el centro del problema y evitar que el fallo se vuelva a repetir.&lt;/p&gt;
&lt;h5&gt;Configuración manual&lt;/h5&gt;
&lt;p&gt;La monitorización debería ser automática. Al agregar una nueva métrica, nuestro sistema debería detectarla automáticamente. Además deberíamos ser capaces de automatizar los procesos para solucionar problemas detectados por nuestras métricas (&lt;em&gt;runbooks&lt;/em&gt;) y no solamente generar alertas.&lt;/p&gt;
&lt;h3&gt;Patrones&lt;/h3&gt;
&lt;p&gt;Una vez vistos los patrones a evitar, toca ver cuales son las buenas prácticas para monitorizar. Muchos de estos patrones son el contrapunto de los anti patrones vistos en la sección anterior, pero con más información sobre cómo implementarlos.&lt;/p&gt;
&lt;h5&gt;Compón métricas para hacer tu plataforma&lt;/h5&gt;
&lt;p&gt;Usa múltiples herramientas de monitorización e intenta acoplarlas entre ellas sin forzar para crear tu plataforma de monitorización. Una plataforma de monitorización se compone de varios sistemas para diferentes tareas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obtención de datos. Para recibir datos, puede hacer push (el sistema las recibe de los diferentes nodos) o pull (el sistema las solicita a los nodos). Los datos que recibe son métricas o logs.&lt;/li&gt;
&lt;li&gt;almacenamiento de datos.&lt;/li&gt;
&lt;li&gt;visualización de los datos recopilados.&lt;/li&gt;
&lt;li&gt;generar analíticas y reportes&lt;/li&gt;
&lt;li&gt;enviar alertas&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Monitorizar desde la perspectiva del usuario&lt;/h5&gt;
&lt;p&gt;Si tienes que empezar a monitorizar algo, empieza a hacerlo desde la perspectiva del usuario. Esto permite tener una visibilidad mucho mayor sobre el uso y el estado de tu sistema. Una de las métricas mas sencillas y efectivas es analizar el código HTTP y la latencia de tus servicios.&lt;/p&gt;
&lt;h5&gt;Comprar mejor que construir&lt;/h5&gt;
&lt;p&gt;No tener que montar tu propio sistema de monitorización es más barato de lo que parece. La inversión necesaria en conocimientos, personal y el tiempo dedicado a esta tarea en vez de al producto principal de tu empresa compensa de sobra el gasto en cualquier SaaS.&lt;/p&gt;
&lt;h5&gt;Mejora continua&lt;/h5&gt;
&lt;p&gt;Es importante seguir trabajando día a día en tus métricas y en tu sistema de monitorización. Lo que es útil y te permite realizar seguimiento de tu sistema en este instante puede dejar de serlo la próxima semana.&lt;/p&gt;
&lt;h3&gt;Gestión de incidencias&lt;/h3&gt;
&lt;p&gt;Una vez tienes diseñado tu sistema de monitorización, el siguiente paso es agregar alertas en caso de que algo no funcione como se espera y cómo actuar en ese escenario.&lt;/p&gt;
&lt;p&gt;Sobre los tipos de alerta, se pueden diferencias dos alertas a generar: alertas que requieren una acción inmediata (no funciona el sistema, la base de datos es inaccesible) o alertas para informar de que algo no ha funcionado pero no requieren acción inmediata (un cron no se ha ejecutado). En base a esto, podemos ver diferentes tipos de alertas: las que requieren acción inmediata deberían generar una llamada o algún tipo de mensaje que requiera respuesta inmediata, las segundas algún tipo de alerta asíncrona (mensaje en un canal de slack, intenta evitar emails) y en caso de no requerir ni siquiera acción solamente almacenarla dentro de tus ficheros de logs, algo que debería pasar en todos los casos.&lt;/p&gt;
&lt;p&gt;Intenta generar &lt;em&gt;runbooks&lt;/em&gt;, documentos que permitan realizar un diagnóstico y aplicar una solución a cualquier persona independientemente de su conocimiento sobre esa parte del sistema: qué hace el servicio afectado, quién es el responsable, sus dependencias, un resumen de su diseño, cuáles son sus métricas o que alertas tiene implementadas. Evita abusar de este tipo de documentos para solucionar problemas, si un problema se puede solucionar con una serie de comandos... ¿no es mejor implementar esa solución dentro de tu sistema que dejarla dentro de un documento?&lt;/p&gt;
&lt;p&gt;A la hora de definir los umbrales para las alertas, evita tener valores numéricos arbitrarios. Define tus valores en base a cambios drásticos, percentiles o comparaciones con periodos pasados para evitar lanzar alertas que realmente no lo son. También es importante evitar alarmas "ruidosas", que se envían con frecuencia. En caso de tener alguna alarma que no requieran que nadie actúe, que se hayan recibido múltiples veces en el último mes y se hayan ignorado o que la acción llevada a cabo pueda ser automatizada, borra dicha alerta lo más pronto posible. Generar muchas alertas falsas suele derivar en fatiga y en que tu equipo termine ignorando estas notificaciones, incluso cuando estas son de verdad.&lt;/p&gt;
&lt;p&gt;En muchos proyectos es necesario tener un equipo &lt;em&gt;on-call&lt;/em&gt;, que tenga que estar disponible fuera de horario laboral por si hay algún problema (remuneradas siempre, por supuesto). En estos casos, es muy importante el punto anterior: evitar lanzar alertas que realmente no lo son, ya que a nadie le gusta que le despierten a las 3 de la mañana con una falsa alarma. De igual forma es importante que tus alertas no sean excesivas, ya que estar constantemente apagando fuegos también es agotador. Es aconsejable tener un sistema de gestión de incidencias para facilitar el trabajo: permite hacer seguimiento, escalar a otros departamentos en caso de ser necesario y documentar las acciones realizadas. Cualquier intervención debería concluir con un postmortem en el que se discuta el problema y se plantee una solución para evitar futuras intervenciones. En estos equipos es importante tener una buena rotación, con mucho tiempo entre guardia y guardia para poder descansar. También es importante compensar a la gente que está de guardia, tanto económicamente (con bonus extra en caso de realizar intervenciones) cómo con días de descanso (siempre viene bien descansar después de varios días pendiente del teléfono por si pasa algo).&lt;/p&gt;
&lt;h3&gt;La importancia de la estadística&lt;/h3&gt;
&lt;p&gt;Como último punto, es importante destacar la importancia de la estadística a la hora de tener buenas métricas. Ten siempre en mente la media, mediana, temporalidad, cuartiles/percentiles y desviación estándar a la hora de calcular métricas y alertas para tener información mas relevante.&lt;/p&gt;
&lt;p&gt;En el &lt;a href="tacticas-monitorizacion"&gt;siguiente artículo&lt;/a&gt; nos centraremos en las diferentes partes del sistema a monitorizar.&lt;/p&gt;</content><category term="Monitoring"></category><category term="libros"></category><category term="tech"></category><category term="monitoring"></category><category term="practical monitoring"></category></entry><entry><title>The Pragmatic Programmer: mis notas</title><link href="https://darkrodry.github.io/pragmatic-programmer-notas.html" rel="alternate"></link><published>2022-05-14T00:00:00+02:00</published><updated>2022-05-14T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2022-05-14:/pragmatic-programmer-notas.html</id><summary type="html">&lt;p&gt;Hace muchos años (en mis comienzos en el mundo del desarrollo) me leí el libro &lt;a href="https://www.amazon.es/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052"&gt;The Pragmatic Programmer&lt;/a&gt;. Recientemente, un compañero me comentó que se lo estaba leyendo, ya que es un libro muy recomendado en el sector, y me ha dado por revisar las notas que tomé en su día sobre el libro. Con intención de recordarlas, y ya de paso pasarlas a limpio, he decidido subirlas aquí por si a alguien más le pueden interesar.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hace muchos años (en mis comienzos en el mundo del desarrollo) me leí el libro &lt;a href="https://www.amazon.es/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052"&gt;The Pragmatic Programmer&lt;/a&gt;. Recientemente, un compañero me comentó que se lo estaba leyendo, ya que es un libro muy recomendado en el sector, y me ha dado por revisar las notas que tomé en su día sobre el libro. Con intención de recordarlas, y ya de paso pasarlas a limpio, he decidido subirlas aquí por si a alguien más le pueden interesar.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 1: Care about your craft.&lt;/strong&gt; No hay otros puntos importantes en el desarrollo de software si no te preocupas por hacer las cosas bien.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 2: Think! about your work.&lt;/strong&gt; Piensa en lo que haces mientras lo estás haciendo. Se crítico y valora tu trabajo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 3: Provide options, don't make lame excuses.&lt;/strong&gt; Tu papel es el de proporcionar soluciones, opciones y alternativas a los problemas. Si algo sale mal, no pierdas el tiempo buscando excusas y dedícalo a ver cómo puedes salvar la situación.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 4: Don't live with broken windows.&lt;/strong&gt; Para evitar que el mal código eche raíces, nunca dejes "ventanas rotas" (malos diseños, decisiones erroneas o mal código) sin arreglar cuando las veas. Del mismo modo, evita romper ventanas cuando salga algún fuego, evitando las posteriores consecuencias.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 5: Be a catalyst for change.&lt;/strong&gt; No puedes forzar a la gente a adoptar una solución Si ves una mejora obvia, impleméntala aún sin permiso y enséñale a la gente cómo podría mejorar su futuro adoptándola. Es mejor pedir perdón que pedir permiso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 6: Remember the big picture.&lt;/strong&gt; Ten siempre en mente todo lo que sucede a tu alrededor, no sólo lo que estás trabajando. Los cambios pequeños pueden desmoronar todo el sistema.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 7: Make quality a requirement issue.&lt;/strong&gt; El entorno y la calidad del software deberían estar incluidos en los requisitos del sistema. Muchos usuarios prefieren un software funcional hoy que vaya incluyendo mejoras y puliéndose en el tiempo que esperar un año a una versión completa. Haz software que sea "lo suficientemente bueno". También debes saber cuando parar de refinar y mejorar un programa, ya que el resultado puede no terminar siendo el deseado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 8: Invest regularly in your knowledge portfolio.&lt;/strong&gt; Intenta ampliar tus conocimientos invirtiendo en ellos regularmente, aunque sea en pequeñas cantidades. Diversifica tu aprendizaje con diferentes tecnologías y arriesgando en algunas de ellas (no todas), e investigando tecnologías emergentes (buy low sell high). Revisa y balancea tus inversiones periódicamente intentando encontrar un equilibrio entre ellas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 9: Critically analyze what you read and hear.&lt;/strong&gt; No te dejes impresionar por los comerciales, el hype o falsos gurús. Analiza con ojo crítico todo e intenta comprobar cómo adaptarlo a tus proyectos o tu portfolio de conocimientos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 10: It's both what you say and the way you say it.&lt;/strong&gt; Intenta comunicar tus ideas lo mejor posible para hacerlas entendibles a todas las personas. Analiza lo que quieres decir, conoce a tu audiencia y adapta tu discurso. Elige un momento apropiado y un estilo adecuado (documentación, email, charla...). Cuida la presentación y haz que luzca bien. Involucra a tu audiencia y devuelve lo que esta te ofrece, respondiendo preguntas o debatiendo nuevas propuestas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 11: Don't repeat yourself.&lt;/strong&gt; Toda representación del conocimiento debe tener una única, no ambigua y autoritaria representación dentro del sistema. La repetición de código viene dada por 4 posibles factores: duplicación impuesta (por el lenguaje, documentación, entorno...), inadvertida (el desarrollador no es consciente), impaciente (se duplica código por ser la opción rápida y sencilla) o inter developer (varios desarrolladores duplican código dentro de un mismo proyecto sin conocer el código del otro).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 12: Make it easy to reuse.&lt;/strong&gt; Aplicando el principio anterior puedes conseguir un entorno donde es fácil encontrar y reutilizar funcionalidades. Esto implicará que la gente reutilice código con más facilidad&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 13: Eliminate effects between unrelated things.&lt;/strong&gt; Se dice que un sistema es ortogonal cuando la variación de un elemento no afecta a los demás, ganando en productividad y reduciendo riesgos riesgos. Esto se consigue creando componentes que sean autocontenidos, independientes y con una única responsabilidad. Para que tu proyecto tenga más ortogonalidad tienes que tener en cuenta los equipos del proyecto (cuanto más se pueda separar sin causar problemas mejor), los diseños, las herramientas y librerías utilizadas, el código (desacoplado, sin usar datos globales y evitando duplicidad), el testing y una buena documentación.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 14: There are no final decisions.&lt;/strong&gt; Intenta modularizar tu código de tal manera que luego pueda ser propenso a cambios (incluso radicales) sin necesitar alterar el sistema completo. Abstrae todos los módulos usando interfaces, automatizando el código o aplicando patrones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 15: Use tracer bullets to find the target.&lt;/strong&gt; Intenta desarrollar un producto mínimo para empezar a ver resultados y obtener feedback, viendo así si tu propuesta y algoritmos se acercan al objetivo planteado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 16: Prototype to learn.&lt;/strong&gt; Con un prototipo puedes ser capaz de ver la arquitectura, nuevas funcionalidades en un sistema existente, la estructura externa de los datos, analizar herramientas de terceros, el rendimiento o el diseño de las interfaces. El valor no está en el código que haces, sino en el conocimiento que adquieres.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 17: Program close to the domain problem.&lt;/strong&gt; Intenta trabajar con expresiones relacionadas con el dominio (nombres de métodos, variables, ficheros...) reconocibles por cualquier usuario.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 18: Estimate to avoid surprises.&lt;/strong&gt; Estima antes de empezar, desde plazos a rendimiento o memoria. Para estimar correctamente debes comprender el problema, construir un modelo mental y separarlo en componentes, estimar el coste de cada uno de ellos para obtener la respuesta. Esto te permite sacar a flote potenciales problemas antes de empezar a trabajar. Analiza tus estimaciones para aprender a hacer mejores estimaciones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 19: Iterate the schedule with the code.&lt;/strong&gt; Es difícil estimar un proyecto desconocido (dominio, tecnología, equipo...), por lo que es recomendable iterar la planificación periódicamente: comprueba requisitos, analiza los riesgos, diseña, implementa y validad con los usuarios.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 20:? Keep knowledge in plain text.&lt;/strong&gt; El texto plano es entendible por todo el mundo, por lo que es una forma muy útil de mantener la información con el paso del tiempo. Los ficheros de texto plano pueden ser computables, por lo que se pueden utilizar para testear y ayudar al testeo, y es común utilizarlos como ficheros de configuración.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 21: Use the power of command shells.&lt;/strong&gt; Conocer los comandos de la terminal ofrece muchas más posibilidades que usar la GUI, permitiendo además automatizar tareas mediante macros.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 22: Use a single editor well.&lt;/strong&gt; Conoce los atajos de teclado y las opciones que tu editor posee. El editor debe ser configurable (atajos, estilos, tamaños, ventanas...), extensible (agregar nuevos lenguajes) y programable (macros, snippets).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 23: Always use source code control.&lt;/strong&gt; Esta herramienta te permite controlar el historial de un proyecto (sea de código o no) pudiendo volver hacía atrás en caso de necesitarlo, almacenar la información y trabajar en paralelo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 24: Fix the problem, not the blame.&lt;/strong&gt; Los bugs no son un problema de una persona, son de todo el equipo. Localízalos y arréglalos, no pierdas el tiempo buscando a un culpable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 25: Don't panic when debugging.&lt;/strong&gt; Antes de comenzar a debugear, piensa en las causas del bug. Analiza las condiciones bajo las que se produce y profundiza, no apliques un parche superficial. Las estrategias para debugear son analizar los datos utilizados (tipos, valores, etc), agregar trazas para ver el estado del sistema, contarle el flujo a un "patito de goma" y no culpar a terceros (librerías o sistemas operativos).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 26: &lt;em&gt;"select"&lt;/em&gt; isn't broken.&lt;/strong&gt; El error probablemente esté en tu código, no en el de otros. Las librerías y los sistemas operativos están suficientemente testeados y probados como para no haber notificado el error que estás buscando.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 27: Don't assume it - prove it.&lt;/strong&gt; Prueba que tu código funcione con datos y condiciones de entornos reales antes de decir que el error no se encuentra en él. Una vez localizado, asegúrate de agregar test y todo lo necesario para que los errores no vuelvan a repetirse.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 28: Learn a text manipulation language.&lt;/strong&gt; Aprende a hacer scripts que trabajen con texto plano con lenguajes como Python o Perl. Esto te puede ayudar a automatizar tareas o producir documentos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 29: Write code that writes code.&lt;/strong&gt; Aprende a construir generadores de código para automatizar tareas. Esto permite variar la especificación de los datos y autogenerar sus implementaciones (bases de datos, objetos, estructuras...) evitando duplicidades. Los generadores de código pueden ser pasivos (se utilizan para una sola tarea, cómo generar templates o traducir código) o activos (tareas repetitivas, cómo generar objetos a partir de la base de datos o una configuración inicial).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 30: You can't write perfect software.&lt;/strong&gt; Diseña tu código de forma que sea resistente a errores.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 31: Design with contracts.&lt;/strong&gt; Haz código que cumpla exactamente lo especificado definiendo contratos. Tu código debe ser "vago" y ceñirse a lo que hace, aceptando lo mínimo posible y devolviendo lo que promete. Dadas unas precondiciones cambiar el estado en función de las mismas teniendo unas invariantes en el proceso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 32: Crash early.&lt;/strong&gt; Si se detecta un fallo y no se puede arreglar, es mejor que el flujo se detenga lo antes posible a que continue la ejecución modificando cosas críticas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 33: If it can't happen, use assertions to ensure that it won't.&lt;/strong&gt; Nunca des por hecho que una circunstancia no se va a dar y usa &lt;em&gt;assertions&lt;/em&gt; para validar valores en tu código.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 34: Use exceptions for exceptional problems.&lt;/strong&gt; No uses excepciones para controlar el flujo de la aplicación, solo para cosas excepcionales. Usar demasiadas excepciones pueden terminar derivando en problemas de &lt;em&gt;spaghetti code&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 35: Finish what you start.&lt;/strong&gt; Controla la creación y supresión de recursos de tus aplicaciones. Si empiezas a utilizar un recurso, asegurate de&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 36: Minimize coupling between modules.&lt;/strong&gt; Intenta proporcionarle a los constructores y métodos de toda la información necesaria directamente, eliminando el acoplamiento entre módulos. Aplica siempre la &lt;a href="https://es.wikipedia.org/wiki/Ley_de_Demeter"&gt;Ley de Demeter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 37: Configure, don't integrate.&lt;/strong&gt; Intenta usar metadatos para permitir modificar el programa sin tener que modificar el código, asi como almacenar todas las configuraciones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 38: Put abstractions in code, details in metadata.&lt;/strong&gt; Programa para el caso general y almacena las especificaciones y configuraciones fuera del código compilable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 39: Analyze workflows to improve concurrency.&lt;/strong&gt; Usar diagramas de actividad permite ver como podemos maximizar el paralelismo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 40: Design using services.&lt;/strong&gt; Crea pequeños servicios independientes con una interfaz bien definida que permitan realizar tareas de forma independiente en paralelo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 41: Always design for concurrency.&lt;/strong&gt; Al diseñar objetos o módulos, piensa que estos se pueden ejecutar en paralelo, por lo que es recomendable intenta que se pueda acceder a su estado de forma segura. Intenta eliminar siempre estados globales.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 42: Separate views from models.&lt;/strong&gt; Separando la responsabilidad de los elementos respecto a sus vistas ganas flexibilidad. También es recomendable separar la vista del modelo que la controla (MVC, MVP...).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 43: Use blackboards to coordinate workflows.&lt;/strong&gt; De esta forma, tendrás un repositorio común de objetos que pueden ser fácilmente utilizados en función de los requisitos del programa, controlando además el flujo de la aplicación.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 44: Don't program by coincidence.&lt;/strong&gt; Las cosas no deben funcionar por casualidad. Documenta y escribe código que funcione y sea sencillo, testea, entiende el porqué de ese código o cámbialo. No programes a ciegas sin entender que está sucediendo por debajo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 45: Estimate the order of your algorithms.&lt;/strong&gt; A la hora de programar estima la complejidad de tu código.Si esta es elevada, dale una pensada a los algoritmos y hazlos eficientes. Usa estas estimaciones: bucles simples &lt;code&gt;O(n)&lt;/code&gt;, anidados &lt;code&gt;O(n^2)&lt;/code&gt;, particionado binario &lt;code&gt;O(log(n))&lt;/code&gt;, divide y vencerás &lt;code&gt;O(nlog(n))&lt;/code&gt; y combinatorias &lt;code&gt;O(2^n)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 46: Test your estimates.&lt;/strong&gt; Prueba tanto en un entorno real como en uno de pruebas para entender mejor el funcionamiento de tus algoritmos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 47: Refactor early, refactor often.&lt;/strong&gt; No esperes a que pase el tiempo para refactorizar y hazlo con frecuencia. Refactoriza para eliminar duplicidad, para mejorar la independencia de tus módulos, al mejorar tu conocimiento del problema o por rendimiento.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 48: Design to test.&lt;/strong&gt; A la hora de programar, diseña y plantea tanto el programa como los tests, viendo así condiciones que deben cumplir y posibles problemas. Esto te permite desarrollar una buena interfaz antes de darle contenido.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 49: Test your software, or your users will.&lt;/strong&gt; Crea tests desde el principio y prueba bien tu código, no dejes que sean los usuarios los que encuentren los fallos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 50: Don't use wizard code you don't understand.&lt;/strong&gt; Si vas a generar código base usando &lt;em&gt;wizards&lt;/em&gt;, detente y asegúrate de comprender todo lo que vas a generar. En caso contrario descarta su uso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 51: Don't gather requirements - dig for them.&lt;/strong&gt; Muchas veces los clientes no saben concretar los requisitos. Haz preguntas, detalla y concreta el comportamiento. Los requisitos se ocultan bajo capas de supuestos, conceptos erróneos y burocracia.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 52: Work with a user to thing like a user.&lt;/strong&gt; Trabaja con él, entiendo su trabajo, tareas, problemas... para poder hacer un software que se adapte a sus necesidades.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 53: Abstraction live longer than details.&lt;/strong&gt; Desarrolla intentando abstraer datos genéricos, contratos y condiciones generales sobre implementaciones concretas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 54: Use a project glossary.&lt;/strong&gt; Ten un único glosario de palabras relacionadas con el proyecto y documenta y programa en base a dicho glosario. Mantén y actualiza el glosario.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 55: Don't think outside the box - find the box.&lt;/strong&gt; Identifica todas las restricciones reales del problema, no solo las indicadas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 56: Start when you are ready.&lt;/strong&gt; Tu experiencia te puede advertir de que algo no está bien diseñado antes de empezar: escúchala.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 57: Some things are better done than described.&lt;/strong&gt; Al desarrollar, puedes localizar cosas que pueden ser generalizadas, algoritmos o formas más óptimas de hacer algo, o problemas y limitaciones no documentadas. Es mejor empezar a desarrollar que perder demasiado tiempo buscando la especificación perfecta.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 58:? Don't be a slave to formal methods.&lt;/strong&gt; Antes de aplicar una nueva tecnología o metodología, ponla en el contexto del proyecto para analizar sus ventajas y desventajas y su aplicación a las diferentes habilidades del equipo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 59: Expensive tools do not produce better designs.&lt;/strong&gt; Usa herramientas puede ayudarte a diseñar un programa, pero no bases tu programa en ellas. El coste de las herramientas no quita que los resultados estén mal detallados o contengan errores.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 60: Organize around functionality, not job functions.&lt;/strong&gt; Los diferentes trabajos realizados dentro de un proyecto (diseñadores, programadores, testers, producto...) no tienen que trabajar de forma aislada. Es mejor crear equipos por funcionalidades que por tareas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 61: Don't use manual procedures.&lt;/strong&gt; Automatiza todas las tareas manuales para evitar problemas de interpretación o saltos de pasos. Usa &lt;em&gt;shell scripts&lt;/em&gt; o constantes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 62: Test early, test often, test automatically.&lt;/strong&gt; Empieza haciendo test desde el principio, y testea todo el código producido. Crea test que se puedan ejecutar automáticamente (desde la consola, con cada commit, por la noche...).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 63:? Coding ain't done until all test runs.&lt;/strong&gt; Ejecuta siempre los test antes de decir que algo está terminado y comprueba que todo tiene un test. Testea de forma unitaria, la integración de los componentes, la validación y verificación de los usuarios (no automatizable), los recursos necesarios para su ejecución así como errores y recuperación, la eficiencia y la usabilidad.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 64: Use saboteurs to test your testing.&lt;/strong&gt; Comprueba que los test que has escrito fallan al romper intencionadamente el código, verificando que el test funciona correctamente. Puedes designar un saboteador que desconozca los test para introducir bugs y comprobar el resultado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 65: Test state coverage, not code coverage.&lt;/strong&gt; La cobertura del código en líneas es una métrica útil, pero es mas importante asegurarse de que se están testeando los estados suficientes. Un test puede pasar por un fragmento de código y no testear todos los estados necesarios del mismo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 66: Find bugs once.&lt;/strong&gt; Si encuentras un bug, crea un test para que no se vuelva a repetir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 67: Treat English as just another programming language.&lt;/strong&gt; Aplica todos los consejos aprendidos a tu documentación (DRY, metadata, generación automática...).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 68: Build documentation in, don't bolt it on.&lt;/strong&gt; Hay dos tipos de documentación: interna (código, diseño, test...) y externa (manuales de usuario...). La segunda suele estar desactualizada y no documenta todo lo que puede pasar.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 69: Gently exceed your users expectations.&lt;/strong&gt; Intenta no sobrepasar en exceso las expectativas de los usuarios, entregando un poco más de lo prometido. Nunca te quedes por debajo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip 70: Sign your work.&lt;/strong&gt; Deberías estar orgulloso de tu trabajo cómo para poder firmarlo.&lt;/p&gt;</content><category term="Libros"></category><category term="libros"></category><category term="tech"></category><category term="pragmatic programmer"></category></entry><entry><title>Testing doubles</title><link href="https://darkrodry.github.io/test-doubles.html" rel="alternate"></link><published>2022-04-12T00:00:00+02:00</published><updated>2022-04-12T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2022-04-12:/test-doubles.html</id><summary type="html">&lt;p&gt;A la hora de testear es necesario falsear implementaciones de dependencias en nuestro código a testear. Para ello usaremos &lt;strong&gt;test doubles&lt;/strong&gt;, que nos permitirán sustituir nuestras implementaciones por algo falso que tendremos bajo nuestro control.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A la hora de testear es necesario falsear implementaciones de dependencias en nuestro código a testear. Para ello usaremos &lt;strong&gt;&lt;em&gt;test doubles&lt;/em&gt;&lt;/strong&gt;, que nos permitirán sustituir nuestras implementaciones por algo falso que tendremos bajo nuestro control. Existen varios tipos de &lt;em&gt;test doubles&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;fake&lt;/em&gt;&lt;/strong&gt;: implementación funcional pero con valores generados aleatoriamente. Los &lt;em&gt;fake&lt;/em&gt; se suelen generar utilizando un builder especial conocido como &lt;em&gt;objectMother&lt;/em&gt;, que da valores aleatorios a todas las propiedades salvo a aquellas que queramos especificar para nuestro test.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;dummy&lt;/em&gt;&lt;/strong&gt;: implementa la interfaz pero todos sus métodos no tienen implementación. Suelen ser elementos que necesita nuestro test pero que no va a utilizar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;stub&lt;/em&gt;&lt;/strong&gt;: es una especie de dummy pero en el que todos los valores están predefinidos, sin lógica. Se usan para falsear datos que necesita nuestro test pero de los cuales no nos importa el valor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;spy&lt;/em&gt;&lt;/strong&gt;: permite observar si ha habido alguna interacción o llamada a la implementación, pero no modela la implementación (solo controla la entrada). Muy útiles para verificar que las llamadas a dependencias de nuestro test se hacen como esperamos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;mock&lt;/em&gt;&lt;/strong&gt;: implementación pensada para validar los argumentos y, a diferencia de &lt;em&gt;spy&lt;/em&gt;, modelar una implementación de salida. Se usa cuando necesitamos controlar la respuesta de nuestras dependencias externas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Al final, a la hora de hacer los test acostumbramos a llamar a todos estos doubles de la misma forma (incluso alguna librería mezcla los nombres). Lo importante es saber que tenemos todas estas opciones en nuestra mano y saber cómo y cuándo utilizarlas para simplificar nuestros test.&lt;/p&gt;</content><category term="Testing"></category><category term="testing"></category><category term="tech"></category></entry><entry><title>Cómo montar tu propio blog</title><link href="https://darkrodry.github.io/como-montar-tu-propio-blog.html" rel="alternate"></link><published>2017-05-23T00:00:00+02:00</published><updated>2023-04-02T00:00:00+02:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2017-05-23:/como-montar-tu-propio-blog.html</id><summary type="html">&lt;p&gt;&lt;em&gt;(Desactualizado)&lt;/em&gt; Después de mucho tiempo queriendo escribir algún artículo, finalmente me he decidido empezar por algo sencillo: un pequeño tutorial contando el proceso de creación del blog y su puesta a punto para publicar automáticamente los cambios realizados.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Nota: este artículo detalla la versión anterior de mi blog. Actualmente el artículo se publica usando Github action y varias de las configuraciones y versiones están desactualizadas. Si tienes cualquier duda consulta el repositorio o mándame un mensaje si necesitas un cable ;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Después de mucho tiempo queriendo escribir algún artículo, finalmente me he decidido empezar por algo sencillo: un pequeño tutorial contando el proceso de creación del blog y su puesta a punto para publicar automáticamente los cambios que realizados. Como ya mencioné anteriormente, este blog está montado usando &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;, &lt;a href="http://docs.getpelican.com/en/stable/"&gt;Pelican&lt;/a&gt; con &lt;a href="https://github.com/alexandrevicenzi/Flex"&gt;Flex-Theme&lt;/a&gt; y &lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A lo largo de este (largo) artículo explicaré como he utilizado todas estas herramientas para crear y automatizar todo el funcionamiento del blog.&lt;/p&gt;
&lt;h2&gt;Preparando el repositorio&lt;/h2&gt;
&lt;p&gt;El primer paso para montar el blog es crear un repositorio en el que subir el código. En mi blog he utilizado un repositorio de GitHub, ya que en combinación con GitHub Pages permite mostrar código HTML sin necesidad de montar nada más. Otros populares repositorios, como Gitlab o Bitbucket tienen soluciones similares, aunque hay pasos en el tutorial que pueden variar.&lt;/p&gt;
&lt;p&gt;Para crear el repositorio, el único requisito es que su nombre siga el patrón &lt;em&gt;username.github.io&lt;/em&gt;, donde &lt;em&gt;username&lt;/em&gt; será tu nombre de usuario de Github (en mi caso, &lt;em&gt;darkrodry.github.io&lt;/em&gt;). En este repositorio, todo el contenido de la rama &lt;em&gt;master&lt;/em&gt; será lo que se muestre en el blog. Yo he creado además otra rama llamada &lt;em&gt;source&lt;/em&gt; para subir el código utilizado para generar el blog.&lt;/p&gt;
&lt;p&gt;También os recomiendo darle un vistazo al funcionamiento de &lt;a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules"&gt;git submodules&lt;/a&gt;, ya que lo utilizaremos más adelante para agregar algunas dependencias necesarias para la compilación.&lt;/p&gt;
&lt;h2&gt;Iniciando Pelican&lt;/h2&gt;
&lt;p&gt;Como indican en su &lt;a href="http://docs.getpelican.com/en/stable/"&gt;web&lt;/a&gt;, Pelican es una herramienta escrita en Python que permite generar sitios web estáticos a partir de una serie de ficheros &lt;a href="https://es.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; o &lt;a href="http://docutils.sourceforge.net/rst.html"&gt;reStructuredText&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para instalar Pelican en tu ordenador necesitas tener Python. Recomiendo usar la versión 3.5 o superior, ya que tuve algún problema usando la 2.7 (si queréis mantener ambas versiones probad &lt;a href="https://github.com/pyenv/pyenv"&gt;pyenv&lt;/a&gt;). Pelican se encuentra dentro de &lt;em&gt;pip&lt;/em&gt;, por lo que instalarlo es tan sencillo como ejecutar en tu terminal:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;pip install pelican&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Pelican proporciona un simple quickstart para generar el esqueleto del proyecto, así como los ficheros de configuración y un Makefile para ejecutar el mismo. Para ejecutar este quickstart (dentro de la rama elegida para subir el código al repositorio) escribe en tu terminal el siguiente comando y responde a las preguntas:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;pelican-quickstart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;En mi blog he usado en gran parte la configuración por defecto, a excepción de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nombre y autor del blog&lt;/li&gt;
&lt;li&gt;url: usad la que os debería haber generado GitHub&lt;/li&gt;
&lt;li&gt;cuando pregunte si queréis publicar vuestra web en GitHub Pages responded que sí, y confirmad la url.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No os preocupéis si configuráis algo mal, está configuración se puede modificar más adelante sin ningún problema.&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto" src="images/pelican-quickstart-demo.png" alt="ejemplo de ejecución del quickstart"&gt;&lt;/p&gt;
&lt;p&gt;Una vez finalizado el quickstart, podrás observar que se han generado una serie de ficheros y carpetas. Los más importantes son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;content/&lt;/em&gt;: en este directorio va todo el contenido del blog (artículos, imágenes...)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;output/&lt;/em&gt;: aquí se almacena el contenido auto generado al usar Pelican. Es muy recomendable agregar este fichero a nuestro .gitignore&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pelicanconf.py&lt;/em&gt;: fichero de configuración principal con parámetros comunes y de despliegue local&lt;/li&gt;
&lt;li&gt;&lt;em&gt;publishconf.py&lt;/em&gt;: fichero que sobrescribe parte de la configuración de &lt;em&gt;pelicanconf.py&lt;/em&gt; con los parámetros necesarios a la hora de publicar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Antes de continuar, puedes comprobar que todo se ha generado correctamente con el siguiente comando:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;make html &amp;amp;&amp;amp; make serve&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Una vez se haya generado el html y se levante el servidor, carga la url &lt;a href="http://localhost:8000/"&gt;http://localhost:8000/&lt;/a&gt; en tu navegador para ver tus avances.&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto" src="images/pelican-first-execution.png" alt="blog desplegado por defecto"&gt;&lt;/p&gt;
&lt;h2&gt;Creando el primer post&lt;/h2&gt;
&lt;p&gt;Una vez llegados a este punto, es el momento de empezar a agregar contenido al blog. Pelican interpreta que cualquier fichero dentro del directorio &lt;em&gt;content/&lt;/em&gt; es un artículo del blog, y los utilizará para generar el contenido del mismo. Hay una excepción a esto, ya que si creamos una carpeta &lt;em&gt;content/pages/&lt;/em&gt; considerará el contenido de la misma como contenido estático del sitio, como puede ser las páginas con información sobre el autor, contacto o proyectos personales.&lt;/p&gt;
&lt;p&gt;Para crear contenido en el blog, puedes utilizar dos formatos: &lt;a href="https://es.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; o &lt;a href="http://docutils.sourceforge.net/rst.html"&gt;reStructuredText&lt;/a&gt;. En mi caso he decidido utilizar Markdown ya que estoy más familiarizado con ello y lo uso con algo de frecuencia.&lt;/p&gt;
&lt;p&gt;Crear un artículo es tan sencillo como agregar un fichero a la carpeta &lt;em&gt;content/&lt;/em&gt; y escribir dentro lo que quieras contar. Para que este artículo sea considerado como tal, hay que agregar antes un pequeño apartado con información sobre el mismo. El resultado de tu artículo&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;Title&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; Título del post &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;(&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;obligatorio&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;)&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Date&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; &lt;/span&gt;&lt;span style="color: #ffb86c"&gt;2017&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;05&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;21&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; &lt;/span&gt;&lt;span style="color: #ffb86c"&gt;10&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;20&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;(&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;obligatorio&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;)&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Modified&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; &lt;/span&gt;&lt;span style="color: #ffb86c"&gt;2017&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;05&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;22&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; &lt;/span&gt;&lt;span style="color: #ffb86c"&gt;19&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #ffb86c"&gt;30&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Category&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; Artículo&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Tags&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; tutorial&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;,&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; blog&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;,&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; pelican&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Slug&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; articulo&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;de&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;-&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;ejemplo&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Authors&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; Rodrigo de Frutos&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;Summary&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;:&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; Resumen sobre el contenido del post&lt;/span&gt;

&lt;span style="color: #f8f8f2"&gt;A partir de aquí&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;,&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt; el contenido de tu nuevo artículo usando &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;*&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;Markdown&lt;/span&gt;&lt;span style="color: #ff79c6"&gt;*.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Una vez creado el artículo, prueba a generar de nuevo el blog y comprueba el resultado.&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto" src="images/pelican-first-post.png" alt="ejemplo de primer artículo creado con pelican"&gt;&lt;/p&gt;
&lt;p&gt;Puedes ver más información sobre cómo crear artículos en &lt;a href="http://docs.getpelican.com/en/stable/content.html#file-metadata"&gt;la documentación de Pelican&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Personalizando el blog&lt;/h2&gt;
&lt;p&gt;A estas alturas puede ser que estés empezando a dudar del estilo ofrecido por tu blog. Otro de los puntos fuertes de Pelican es que permite cambiar el tema del blog, poniendo a disposición de los usuarios un &lt;a href="http://www.pelicanthemes.com/"&gt;gran catálogo de temas&lt;/a&gt;, además de permitir &lt;a href="http://docs.getpelican.com/en/stable/themes.html"&gt;crear nuestros propios temas&lt;/a&gt;. Para mi blog, decidí empezar con la opción sencilla y utilizar un tema ya existente, eligiendo finalmente &lt;a href="https://github.com/alexandrevicenzi/Flex"&gt;Flex&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para agregar este tema (o cualquier otro) al blog, hay que hacer dos pequeños cambios. Lo primero es descargar el código del tema. Yo he decidido importar el tema usando &lt;a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules"&gt;git submodules&lt;/a&gt; con el siguiente comando:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;git submodule add https://github.com/alexandrevicenzi/Flex.git theme-flex&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Una vez tenemos el tema en nuestro repositorio, para que el tema se aplique en el blog hay que modificar el fichero de configuración. Abre el fichero &lt;em&gt;pelicanconf.py&lt;/em&gt; y añade la siguiente línea (o modifícala en caso de que ya exista): &lt;code&gt;THEME = "theme-flex"&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pero esta personalización no acaba aquí. Al abrir el fichero de configuración habrás podido observar que hay otros campos que, o están vacíos o te indican que insertes tu información. Tanto Pelican como el tema que hayas elegido te permitirán personalizar mucha información que mostrará en el blog, como puede ser tu nombre, una biografía, tus redes sociales o agregar Google Analytics. En el caso de Flex, puedes consultar la sección de &lt;a href="https://github.com/alexandrevicenzi/Flex/wiki/Custom-Settings"&gt;custom settings&lt;/a&gt; de su Wiki.&lt;/p&gt;
&lt;p&gt;Para terminar, posiblemente quieras tener una bio un poco más extensa que la que te permite el tema (es muy breve, al estilo Twitter). Pelican interpreta que cualquier fichero dentro de &lt;em&gt;content/pages&lt;/em&gt; es una página estática, sin formato artículo, a tu blog. Todos los ficheros que agregues en este directorio crearán una nueva entrada en el menú de tu blog.&lt;/p&gt;
&lt;h2&gt;Actualización automática&lt;/h2&gt;
&lt;p&gt;La última tarea para dejar tu blog listo es delegar la tarea de la generación del mismo usando integración continua. Para esta tarea he elegido utilizar &lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt;, ya que es un servicio de integración gratuito y muy extendido (y que tenía ganas de probar, la verdad).&lt;/p&gt;
&lt;p&gt;El primer paso de todos es crearte una cuenta en Travis CI asignada a tu usuario de GitHub. Para habilitar Travis CI en nuestro proyecto hay que agregar un fichero &lt;em&gt;.travis.yml&lt;/em&gt; en tu repositorio con el siguiente contenido:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #ff79c6"&gt;language&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;: python&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;python&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - &lt;/span&gt;&lt;span style="color: #bd93f9"&gt;&amp;quot;3.5&amp;quot;&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;branches&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;only&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - [&lt;/span&gt;&lt;span style="color: #8be9fd; font-style: italic"&gt;rama con el código&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;, &lt;/span&gt;&lt;span style="color: #8be9fd; font-style: italic"&gt;source en mi caso&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;]&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;before_install&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - sudo apt-get update &amp;amp;&amp;amp; sudo apt-get --reinstall install -qq language-pack-es&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;install&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - pip install -r requirements.txt&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;script&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - make publish github&lt;/span&gt;
&lt;span style="color: #ff79c6"&gt;env&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;global&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;:&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - LANG=es_ES.UTF-8&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - LC_ALL=es_ES.UTF-8&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;  - &lt;/span&gt;&lt;span style="color: #ff79c6"&gt;secure&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;: [&lt;/span&gt;&lt;span style="color: #8be9fd; font-style: italic"&gt;Token de Travis Encriptado&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Como podrás observar, este fichero tiene un campo &lt;code&gt;secure:&lt;/code&gt; con un token. ¿De dónde sale este token? Es el encargado de permitir a Travis subir a la rama master el resultado de la generación del blog. Este token se puede generar en la sección de ajustes de tu cuenta de GitHub, en la sección de &lt;a href="https://github.com/settings/tokens"&gt;personal access tokens&lt;/a&gt;. Crea tu nuevo token poniéndole un nombre representativo y con permisos completos para acceder a repositorios privados.&lt;/p&gt;
&lt;p&gt;Para dar seguridad a este token, la gente de Travis CI tiene un cliente en Ruby con diferentes herramientas, y entre ellas una para cifrar estas claves. Para instalar estas herramientas necesitaremos tener Ruby en nuestro ordenador e instalar una nueva gema:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;gem install travis&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Una vez instalada, ejecuta el siguiente comando en la raíz de tu repositorio para agregar el token a tu fichero &lt;em&gt;.travis.yml&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;travis encrypt GH_TOKEN=&amp;lt;token en bruto&amp;gt; --add --override&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Para hacer la subida del blog a GitHub utilizaremos &lt;a href="https://github.com/davisp/ghp-import"&gt;ghp-import&lt;/a&gt;, ya que nos facilita bastante la tarea. Para instalarlo simplemente hacemos uso de pip y ejecutamos &lt;code&gt;pip install ghp-import&lt;/code&gt;. Para integrar este comando dentro de nuestro CD es necesario hacer un pequeño cambio en el &lt;em&gt;Makefile&lt;/em&gt; para ejecutar este comando con los parámetros necesarios:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #ff79c6"&gt;github&lt;/span&gt;&lt;span style="color: #f8f8f2"&gt;: publish&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;    ghp-import -b $(GITHUB_PAGES_BRANCH) -n $(OUTPUTDIR)&lt;/span&gt;
&lt;span style="color: #f8f8f2"&gt;    @git push -fq https://${GH_TOKEN}@github.com/$(TRAVIS_REPO_SLUG).git $(GITHUB_PAGES_BRANCH) &amp;gt; /dev/null&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Para poder automatizar la instalación de todas las dependencias del proyecto utilizaremos el fichero &lt;em&gt;requirements.txt&lt;/em&gt;, que agregaremos a nuestro repositorio para poder llevarnos el blog a cualquier lado sin miedo. Para obtener este fichero basta con ejecutar el siguiente comando:&lt;/p&gt;
&lt;div class="highlight" style="background: #282a36"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #f8f8f2"&gt;pip freeze &amp;gt; requirements.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Este comando de pip almacena todos los paquetes que hayas instalado usando pip en tu ordenador, así que es probable que agregue dependencias que no lo son. Si crees que algo de lo que se ha agregado al fichero no es un requisito del blog, no dudes en borrarlo y probar si Travis sigue generando correctamente el blog.&lt;/p&gt;
&lt;p&gt;Una vez hemos terminado de configurar todo lo necesario para tener el blog con despliegue automático, simplemente agrega los últimos cambios y súbelos al repositorio. Pasado uno o dos minutos, deberías ver el resultado de todo el tutorial publicado en tu GitHub Pages personal. ¡Ahora solo te queda crear artículos y mantener actualizado tu blog!&lt;/p&gt;</content><category term="Tutoriales"></category><category term="tech"></category><category term="pelican"></category><category term="tutorial"></category></entry><entry><title>Mis objetivos para 2017</title><link href="https://darkrodry.github.io/objetivos-para-2017.html" rel="alternate"></link><published>2017-01-07T00:00:00+01:00</published><updated>2017-01-07T00:00:00+01:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2017-01-07:/objetivos-para-2017.html</id><summary type="html">&lt;p&gt;Hace unos días David Bonilla publicaba &lt;a href="http://www.bonillaware.com/objetivos-para-2017"&gt;un artículo con sus objetivos para 2017&lt;/a&gt;, en el que además nos animaba a hacer públicos los nuestros. Llevo uno cuantos años queriendo publicar mi propia lista, y aprovechando el proyecto del blog personal he decidido que este sea el primero.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hace unos días David Bonilla publicaba &lt;a href="http://www.bonillaware.com/objetivos-para-2017"&gt;un artículo con sus objetivos para 2017&lt;/a&gt;, en el que además nos animaba a hacer públicos los nuestros. Llevo uno cuantos años queriendo publicar mi propia lista, y aprovechando el proyecto del blog personal he decidido que este sea el primero.&lt;/p&gt;
&lt;p&gt;El año pasado, si bien no tenía una lista, tenía un par de propósitos en mente: adentrarme en el mundo del backend y comenzar a hacer proyectillos personales. En cuanto al primero, comencé el año haciendo backend en Scala y lo he terminado como fullstack backend, por lo que creo que lo he cumplido con creces. Para el segundo, si bien he comenzado a subir cosas a Github, creo que todavía tengo un gran margen de mejora.&lt;/p&gt;
&lt;p&gt;Así que, sin más dilación, os dejo con mis propósitos para 2017:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mastering Scala:&lt;/strong&gt; el año pasado me sirvió para descubrir un nuevo lenguaje de programación, Scala. Este año me gustaría profundizar más tanto en el lenguaje como en la programación funcional, con un objetivo claro: llegar a la &lt;a href="https://skillsmatter.com/conferences/8784-scala-exchange-2017"&gt;Scala Exchange&lt;/a&gt; pudiendo dialogar con mis maestros &lt;a href="https://twitter.com/pirikun"&gt;Ignacio&lt;/a&gt; y &lt;a href="https://twitter.com/JesusMtnezBH"&gt;Jesús&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hacer deporte:&lt;/strong&gt; es una meta constante, y en la que siempre fallo estrepitosamente. Veremos si grabando el reto en piedra consigo empezar a ser constante. Mi objetivo es intentar ir al gimnasio un mínimo de dos veces por semana, para intentar mantener un nivel de forma y energía más normal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Doce meses, doce libros:&lt;/strong&gt; pues eso, quiero volver a recuperar mi hábito por la lectura leyendo una media de un libro no técnico al mes. En estos momentos me encuentro leyendo la &lt;a href="https://es.wikipedia.org/wiki/Serie_de_la_Fundaci%C3%B3n"&gt;serie de la Fundación de Asimov&lt;/a&gt;, si la termino completa este reto estará más que superado. A estos libros también me gustaría sumarle algún libro técnico, pero estos los cuento como fuera de esta meta.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Publicar post técnicos en el blog:&lt;/strong&gt; el motivo por el que he decidido crear el blog es para intentar ser más constante con mis proyectos personales y publicar resúmenes de mis aventuras. Todavía no se muy bien con que trastearé este año (Scala aparte), pero intentaré publicar artículos con algo de regularidad.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto" src="http://i.giphy.com/eNweOH3UEi33a.gif" alt="challenge accepted"&gt;&lt;/p&gt;
&lt;p&gt;Ahora sólo me queda esperar a finales del año para saber si he sido capaz de cumplir estas metas... o al menos ser capaz acercarme a la línea de llegada. ¡Nos vemos en 2018!&lt;/p&gt;</content><category term="Offtopic"></category><category term="offtopic"></category><category term="objetivos"></category></entry><entry><title>¡Bienvenidos a mi blog!</title><link href="https://darkrodry.github.io/bienvenidos-a-mi-blog.html" rel="alternate"></link><published>2017-01-05T00:00:00+01:00</published><updated>2017-01-05T00:00:00+01:00</updated><author><name>DarkRodry</name></author><id>tag:darkrodry.github.io,2017-01-05:/bienvenidos-a-mi-blog.html</id><summary type="html">&lt;p&gt;Durante las próximas semanas espero empezar a llenar de contenido este blog, con artículos sobre aventuras y desventuras con nuevos proyectos y tecnologías. ¡Disfrutad!&lt;/p&gt;</summary><content type="html">&lt;p&gt;¡Bienvenidos a mi blog!&lt;/p&gt;
&lt;p&gt;Después de mucho tiempo debatiendo proyectos con mi buen amigo &lt;a href="https://jesusmtnez.gitlab.io/"&gt;JesusMtnez&lt;/a&gt;, hemos decidido montarnos un blog aprovechando el potencial que ofrece Github Pages (Gitlab en su caso). En este primer post podéis observar el resultado de estos primeros días del año: un blog en Github utilizando &lt;a href="http://docs.getpelican.com/en/stable/"&gt;Pelican&lt;/a&gt; con el tema &lt;a href="https://github.com/alexandrevicenzi/Flex"&gt;Flex&lt;/a&gt; e integración continua con &lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt;. Podéis ver el resultado en &lt;a href="https://github.com/darkrodry/darkrodry.github.io"&gt;el repositorio del blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Durante las próximas semanas espero empezar a llenar de contenido este blog, con artículos sobre aventuras y desventuras con nuevos proyectos y tecnologías. ¡Disfrutad!&lt;/p&gt;
&lt;p&gt;&lt;img style="display: block; margin-left: auto; margin-right: auto" src="images/excited-finn.gif" alt="Finn de hora de aventuras emocionado"&gt;&lt;/p&gt;</content><category term="Offtopic"></category><category term="offtopic"></category></entry></feed>